{
    "comments": [
        {
            "tags": [],
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            },
            "isPrivate": false,
            "code": "module.exports = {\n\tUtil: require(\"util\"),\n\tAssert: require(\"assert\"),\n\tPlugins: require(\"./plugins\"),\n\tInvocation: require(\"./invocation\"),\n\tInterceptor: require(\"./interceptor\"),\n\tProxyInstance: require(\"./proxy-instance\"),\n\tProxyPrototype: require(\"./proxy-prototype\"),\n\tEnumerable: require(\"./extensions/enumerable\")\n};",
            "ctx": {
                "type": "property",
                "receiver": "module",
                "name": "exports",
                "value": "{",
                "string": "module.exports"
            },
            "fileName": "lib/index.js"
        },
        {
            "tags": [],
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            },
            "isPrivate": false,
            "code": "var assert = require(\"assert\");\nvar Invocation = require(\"./invocation\");\nvar ProxyInstance = require(\"./proxy-instance\");\nvar ProxyPrototype = require(\"./proxy-prototype\");\n\nfunction Interceptor(typeOrInstance) {\n\n\tassert(typeOrInstance, \"Scarlet::Interceptor::typeOrInstance == null\");\n\n\tvar self = this;\n\n\tself.targets = [];\n\tself.proxy = null;\n\tself.currentTarget = 0;\n\tself.type = typeOrInstance;\n\tself.proxiedInstance = null;\n\tself.instance = typeOrInstance;\n\n\tself.asType = function() {\n\t\tassert(self.proxy === null, \"Interceptor proxy should only be defined one time using 'asObject()' or 'asType()'\");\n\n\t\tself.proxy = new ProxyPrototype(self);\n\t\tinitProxy();\n\t\treturn self;\n\t};\n\n\tself.asObject = function() {\n\t\tassert(self.proxy === null, \"Interceptor proxy should only be defined one time using 'asObject()' or 'asType()'\");\n\n\t\tself.proxy = new ProxyInstance(self);\n\t\tinitProxy();\n\t\treturn self;\n\t};\n\n\tvar initProxy = function(){\n\t\tassert(self.proxy, \"Please make sure you use the 'asObject()' or 'asType()' method before initializing a proxy\");\n\n\t\tself.proxiedInstance = self.proxy.whenCalled(function(method, args) {\n\n\t\t\tvar _invocation = new Invocation(self.instance, method, args);\n\n\t\t\tvar next = function(error, result){\n\n\t\t\t\tif(self.currentTarget >= self.targets.length){\n\t\t\t\t\tself.currentTarget = 0;\t\n\t\t\t\t\treturn _invocation.proceed();\n\t\t\t\t}\n\n\t\t\t\tvar targetMethod = self.targets[self.currentTarget];\n\t\t\t\tself.currentTarget++;\n\t\t\t\ttargetCall(targetMethod);\n\n\t\t\t\treturn _invocation.result;\n\t\t\t};\n\n\t\t\tvar targetCall = function(target){\n\t\t\t\ttarget.targetMethod.apply(target.targetThisContext,[next,_invocation]);\n\t\t\t};\n\n\t\t\tnext();\n\n\t\t\treturn _invocation.result;\n\n\t\t});\n\t};\n\n\tself.addTarget = function(targetMethod,targetThisContext){\n\t\tvar target = {\n\t\t\ttargetMethod : targetMethod,\n\t\t\ttargetThisContext : targetThisContext\n\t\t};\n\n\t\tself.targets.push(target);\n\t};\n\n}\n\nmodule.exports = Interceptor;",
            "ctx": {
                "type": "declaration",
                "name": "assert",
                "value": "require(\"assert\")",
                "string": "assert"
            },
            "fileName": "lib/interceptor.js"
        },
        {
            "tags": [
                {
                    "type": "category",
                    "string": "Invocation Attributes"
                },
                {
                    "type": "type",
                    "types": [
                        "Object"
                    ]
                }
            ],
            "description": {
                "full": "<p>The original arguments passed into the function being intercepted</p>",
                "summary": "<p>The original arguments passed into the function being intercepted</p>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "self.args = args;",
            "ctx": {
                "type": "property",
                "receiver": "self",
                "name": "args",
                "value": "args",
                "string": "self.args"
            },
            "fileName": "lib/invocation.js"
        },
        {
            "tags": [
                {
                    "type": "category",
                    "string": "Invocation Attributes"
                },
                {
                    "type": "type",
                    "types": [
                        "Object"
                    ]
                }
            ],
            "description": {
                "full": "<p>The reference to self for the original/called methd</p>",
                "summary": "<p>The reference to self for the original/called methd</p>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "self.object = object;",
            "ctx": {
                "type": "property",
                "receiver": "self",
                "name": "object",
                "value": "object",
                "string": "self.object"
            },
            "fileName": "lib/invocation.js"
        },
        {
            "tags": [
                {
                    "type": "category",
                    "string": "Invocation Attributes"
                },
                {
                    "type": "type",
                    "types": [
                        "Function"
                    ]
                }
            ],
            "description": {
                "full": "<p>The method being intercepted</p>",
                "summary": "<p>The method being intercepted</p>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "self.method = method;",
            "ctx": {
                "type": "property",
                "receiver": "self",
                "name": "method",
                "value": "method",
                "string": "self.method"
            },
            "fileName": "lib/invocation.js"
        },
        {
            "tags": [
                {
                    "type": "category",
                    "string": "Invocation Attributes"
                },
                {
                    "type": "type",
                    "types": [
                        "Any"
                    ]
                }
            ],
            "description": {
                "full": "<p>The result of the method being intercepted</p>",
                "summary": "<p>The result of the method being intercepted</p>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "self.result = null;",
            "ctx": {
                "type": "property",
                "receiver": "self",
                "name": "result",
                "value": "null",
                "string": "self.result"
            },
            "fileName": "lib/invocation.js"
        },
        {
            "tags": [
                {
                    "type": "category",
                    "string": "Invocation Attributes"
                },
                {
                    "type": "method",
                    "string": "proceed"
                },
                {
                    "type": "return",
                    "types": [
                        "Function",
                        "Object"
                    ],
                    "description": "of the result of the original method call"
                }
            ],
            "description": {
                "full": "<p>Calls the intercepted method</p>",
                "summary": "<p>Calls the intercepted method</p>",
                "body": ""
            },
            "isPrivate": false,
            "ignore": false,
            "code": "self.proceed = function() {\n\t\tvar parameters = Array.prototype.slice.call(args);\n\t\tself.result = self.method.apply(self.object, parameters);\n\t\treturn self.result;\n\t};\n}\n\nmodule.exports = Invocation;",
            "ctx": {
                "type": "method",
                "receiver": "self",
                "name": "proceed",
                "string": "self.proceed()"
            },
            "fileName": "lib/invocation.js"
        },
        {
            "tags": [],
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            },
            "isPrivate": false,
            "code": "var path = require(\"path\");\nvar assert = require(\"assert\");\n\nfunction Plugins() {\n\n\tvar self = this;\n\t\n\tself.loadPlugin = function($scarlet, pluginPath) {\n\n\t\tassert($scarlet, \"Scarlet::Plugins::loadPlugin::$scarlet == null\");\n\t\tassert(pluginPath, \"Scarlet::Plugins::loadPlugin::pluginPath == null\");\n\n\t\tfullPath = path.normalize(__dirname + \"/../../\" + pluginPath);\n\t\tvar plugin = require(fullPath);\n\n\t\tpluginObject = new plugin($scarlet);\n\t\tpluginObject.initialize();\n\n\t};\n\n}\n\nmodule.exports = new Plugins();",
            "ctx": {
                "type": "declaration",
                "name": "path",
                "value": "require(\"path\")",
                "string": "path"
            },
            "fileName": "lib/plugins.js"
        },
        {
            "tags": [],
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            },
            "isPrivate": false,
            "code": "var enumerable = require(\"./extensions/enumerable\");\n\n\nfunction ProxyInstance(interceptor) {\n\n\tvar self = this;\n\n\tself.interceptor = interceptor;\n\n\tself.whenCalled = function(target) {\n\t\tif (!interceptor.instance.__scarlet) {\n\n\t\t\tinterceptor.instance.__scarlet = {};\n\n\t\t\tenumerable.forEach(interceptor.instance, function(member, memberName) {\n\n\t\t\t\tself.interceptor.instance.__scarlet[memberName] = self.interceptor.instance[memberName];\n\n\t\t\t\tcreatePropertyProxy(member, memberName, target);\n\n\t\t\t\tcreateFunctionProxy(member, memberName, target);\n\n\t\t\t});\n\t\t}\n\n\t\treturn interceptor.instance;\n\t};\n\n\tvar createPropertyProxy = function(member,memberName,target){\n\t\tif (interceptor.instance.hasOwnProperty(memberName) && !(member instanceof(Function)) && (memberName !== \"__scarlet\") && (memberName !== \"__typename\")) {\n\n\t\t\tself.interceptor.instance[memberName] = Object.defineProperty(interceptor.instance, memberName, {\n\n\t\t\t\tconfigurable: true,\n\n\t\t\t\tget: function(){\n\t\t\t\t\treturn target(function(){\n\t\t\t\t\t\treturn self.interceptor.instance.__scarlet[memberName];\n\t\t\t\t\t}, self.interceptor.instance.__scarlet[memberName]);\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tset: function(value){\n\t\t\t\t\ttarget(function(){\n\t\t\t\t\t\tself.interceptor.instance.__scarlet[memberName] = value;\t\n\t\t\t\t\t}, value);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t} else if (interceptor.instance.hasOwnProperty(memberName) && !(member instanceof(Function)) && (memberName === \"__typename\")) {\n\t\t\tself.interceptor.instance.__typename = self.interceptor.instance.__scarlet.__typename;\n\t\t}\n\t};\n\n\tvar createFunctionProxy = function(member,memberName,target){\n\t\tif (member instanceof(Function)) {\n\t\t\tvar originalMethod = self.interceptor.instance.__scarlet[memberName];\n\t\t\t\n\t\t\tself.interceptor.instance[memberName] = function() {\n\t\t\t\treturn target(originalMethod, arguments);\n\t\t\t};\n\n\t\t}\n\t};\n\n\tself.unwrap = function() {\n\n\t\tif (interceptor.instance.__scarlet) {\n\n\t\t\tenumerable.forEach(interceptor.instance, function(member, memberName) {\n\n\t\t\t\tif (member instanceof Function) {\n\t\t\t\t\tvar originalMethod = interceptor.instance.__scarlet[memberName];\n\t\t\t\t\tinterceptor.instance[memberName] = originalMethod;\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\n\t};\n\n}\n\nmodule.exports = ProxyInstance;",
            "ctx": {
                "type": "declaration",
                "name": "enumerable",
                "value": "require(\"./extensions/enumerable\")",
                "string": "enumerable"
            },
            "fileName": "lib/proxy-instance.js"
        },
        {
            "tags": [],
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            },
            "isPrivate": false,
            "code": "var assert = require(\"assert\");\nvar ProxyInstance = require(\"./proxy-instance\");\nvar inherits = require(\"./extensions/inherits\");\nvar enumerable = require(\"./extensions/enumerable\");\n\nfunction ProxyPrototype(interceptor) {\n\n\tvar self = this;\n\n\tself.inheritedType = null;\n\n\tself.interceptor = interceptor;\n\n\tself.whenCalled = function(target) {\n\n\t\tassert(interceptor.type, \"Scarlet::Interceptor::type == null\");\n\t\tassert(interceptor.type.prototype, \"Cannot use 'asType()' for this object because it does not have a prototype\");\n\n\t\tself.inheritedType = function(){\n\n\t\t\tvar self = this;\n\n\t\t\t(function() {\n\t\t\t\tvar interceptorTypeConstructor = function(){\n\t\t\t\t\tvar parameters = Array.prototype.slice.call(arguments);\n\t\t\t\t\tinterceptor.type.apply(self,parameters);\n\n\t\t\t\t\tinterceptor.instance = self;\n\n\t\t\t\t\tvar proxy = new ProxyInstance(interceptor);\n\t\t\t\t\tproxy.whenCalled(target);\n\t\t\t\t};\n\n\t\t\t\treturn target(interceptorTypeConstructor,arguments);\n\t\t\t}());\n\n\t\t};\n\n\t\tinherits(self.inheritedType, interceptor.type);\n\t\treturn self.inheritedType;\n\t\t\n\t};\n\n\tself.unwrap = function() {};\n\n}\n\nmodule.exports = ProxyPrototype;",
            "ctx": {
                "type": "declaration",
                "name": "assert",
                "value": "require(\"assert\")",
                "string": "assert"
            },
            "fileName": "lib/proxy-prototype.js"
        },
        {
            "tags": [
                {
                    "type": "category",
                    "string": "Interception Methods"
                },
                {
                    "type": "class",
                    "string": "Scarlet"
                },
                {
                    "type": "constructor",
                    "string": ""
                },
                {
                    "type": "param",
                    "types": [
                        "Array"
                    ],
                    "name": "pluginArr",
                    "description": "- optional array of plugins to load"
                }
            ],
            "description": {
                "full": "<p>Creates a Scarlet Instance</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet\n    .intercept(someFunction)\n    .using(someInterceptorFunction);\n</pre></div>",
                "summary": "<p>Creates a Scarlet Instance</p>",
                "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet\n    .intercept(someFunction)\n    .using(someInterceptorFunction);\n</pre></div>"
            },
            "isPrivate": false,
            "ignore": false,
            "code": "function Scarlet(pluginArr) {\n\n\t\"use strict\";\n\n\tvar self = this;\n\tself.plugins = {};\n\tself.interceptor = {};\n\tself.lib = require(\"./index\");\n\n\tvar interceptType = function(typeOrInstance) {\n\n\t\tassert(typeOrInstance, \"Cannot have null type or instance\");\n\n\t\tvar _interceptor = new self.lib.Interceptor(typeOrInstance);\n\n\t\treturn _interceptor.asType();\n\t};\n\n\tvar interceptObject = function(typeOrInstance) {\n\n\t\tassert(typeOrInstance, \"Cannot have null type or instance\");\n\n\t\tvar _interceptor = new self.lib.Interceptor(typeOrInstance);\n\n\t\treturn _interceptor.asObject();\n\t};",
            "ctx": {
                "type": "function",
                "name": "Scarlet",
                "string": "Scarlet()"
            },
            "fileName": "lib/scarlet.js"
        },
        {
            "tags": [
                {
                    "type": "category",
                    "string": "Interception Methods"
                },
                {
                    "type": "method",
                    "string": "intercept"
                },
                {
                    "type": "param",
                    "types": [
                        "Function",
                        "Object"
                    ],
                    "name": "typeOrInstance",
                    "description": "the type or instance to be intercepted"
                },
                {
                    "type": "return",
                    "types": [
                        "Function"
                    ],
                    "description": "An interceptor object"
                }
            ],
            "description": {
                "full": "<p>Creates a Scarlet interceptor</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.intercept(someFunction);\n</pre></div>",
                "summary": "<p>Creates a Scarlet interceptor</p>",
                "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.intercept(someFunction);\n</pre></div>"
            },
            "isPrivate": false,
            "ignore": false,
            "code": "self.intercept = function(typeOrInstance) {\n\n\t\tassert(typeOrInstance, \"Cannot have null type or instance\");\n\n\t\tvar self = this;\n\n\t\tif (typeOrInstance.prototype)\n\t\t\tself.interceptor =  interceptType(typeOrInstance);\n\t\telse\n\t\t\tself.interceptor = interceptObject(typeOrInstance);\n\n\t\treturn self;\n\t};",
            "ctx": {
                "type": "method",
                "receiver": "self",
                "name": "intercept",
                "string": "self.intercept()"
            },
            "fileName": "lib/scarlet.js"
        },
        {
            "tags": [
                {
                    "type": "category",
                    "string": "Interception Methods"
                },
                {
                    "type": "method",
                    "string": "using"
                },
                {
                    "type": "param",
                    "types": [
                        "Function"
                    ],
                    "name": "targetMethod",
                    "description": "the method to call when the type or instance is intercepted"
                },
                {
                    "type": "param",
                    "types": [
                        "Function"
                    ],
                    "name": "targetThisContext",
                    "description": "the reference to self/this to be used when calling the intercepotr"
                },
                {
                    "type": "chainable",
                    "string": ""
                },
                {
                    "type": "return",
                    "types": [
                        "Function"
                    ],
                    "description": "A reference to the current interceptor(self)"
                }
            ],
            "description": {
                "full": "<p>Attach an interceptor to the type or instance.  Can be chained with multiple using clauses</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\nfunction interceptor1(proceed) { proceed();}\nfunction interceptor2(proceed) { proceed();}\n\nscarlet.intercept(AnyObject) \n        .using(interceptor1) //->indicates the first interceptor to be called\n        .using(interceptor2); //->indicates the second interceptor to be called\n\n//-> AnyObject will now have the two interceptors attached\n</pre></div>    ",
                "summary": "<p>Attach an interceptor to the type or instance.  Can be chained with multiple using clauses</p>",
                "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\nfunction interceptor1(proceed) { proceed();}\nfunction interceptor2(proceed) { proceed();}\n\nscarlet.intercept(AnyObject) \n        .using(interceptor1) //->indicates the first interceptor to be called\n        .using(interceptor2); //->indicates the second interceptor to be called\n\n//-> AnyObject will now have the two interceptors attached\n</pre></div>    "
            },
            "isPrivate": false,
            "ignore": false,
            "code": "self.using = function(targetMethod,targetThisContext) {\n\t\tassert(targetMethod, \"Cannot have null target for interceptor\");\n\n\t\tif(!targetThisContext)\n\t\t\ttargetThisContext = self.interceptor;\n\n\t\tself.interceptor.addTarget(targetMethod,targetThisContext);\n\n\t\treturn self;\n\t};",
            "ctx": {
                "type": "method",
                "receiver": "self",
                "name": "using",
                "string": "self.using()"
            },
            "fileName": "lib/scarlet.js"
        },
        {
            "tags": [
                {
                    "type": "category",
                    "string": "Interception Methods"
                },
                {
                    "type": "method",
                    "string": "resolve"
                },
                {
                    "type": "return",
                    "types": [
                        "Function"
                    ],
                    "description": "A reference to the function being intercepted"
                }
            ],
            "description": {
                "full": "<p>Provides the type or instance with the added intercepters. This is needed when intercepting a function.</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\n\nAnyObject = scarlet.intercept(AnyObject)\n                    .using(interceptor)\n                    .resolve();\n\n//-> AnyObject will contain the **interceptor**\n</pre></div>    ",
                "summary": "<p>Provides the type or instance with the added intercepters. This is needed when intercepting a function.</p>",
                "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\n\nAnyObject = scarlet.intercept(AnyObject)\n                    .using(interceptor)\n                    .resolve();\n\n//-> AnyObject will contain the **interceptor**\n</pre></div>    "
            },
            "isPrivate": false,
            "ignore": false,
            "code": "self.resolve = function(){\n\t\treturn self.interceptor.proxiedInstance;\n\t};\n\n\tself.release = function() {\n\t\tself.interceptor.proxy.unwrap();\n\t\treturn self;\n\t};",
            "ctx": {
                "type": "method",
                "receiver": "self",
                "name": "resolve",
                "string": "self.resolve()"
            },
            "fileName": "lib/scarlet.js"
        },
        {
            "tags": [
                {
                    "type": "category",
                    "string": "Interception Methods"
                },
                {
                    "type": "method",
                    "string": "loadPlugin"
                },
                {
                    "type": "param",
                    "types": [
                        "Function",
                        "Object"
                    ],
                    "name": "pluginPath",
                    "description": "the plugin to be loaded"
                },
                {
                    "type": "return",
                    "types": [
                        "Function"
                    ],
                    "description": "A reference to scarlet(self)"
                },
                {
                    "type": "chainable",
                    "string": ""
                }
            ],
            "description": {
                "full": "<p>loads a plugin</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.loadPlugin(someScarletPlugin);\n</pre></div>",
                "summary": "<p>loads a plugin</p>",
                "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.loadPlugin(someScarletPlugin);\n</pre></div>"
            },
            "isPrivate": false,
            "ignore": false,
            "code": "self.loadPlugin = function(pluginPath) {\n\t\tself.lib.Plugins.loadPlugin(self, pluginPath);\n\t\treturn self;\n\t};\n\n\tif(pluginArr){\n\t\tif (pluginArr.length) {\n\t\t\tpluginArr.forEach(function(plugin){\n\t\t\t\tself.loadPlugin(plugin);\n\t\t\t});\n\t\t}\t\t\n\t}\n\n}\n\nmodule.exports = Scarlet;",
            "ctx": {
                "type": "method",
                "receiver": "self",
                "name": "loadPlugin",
                "string": "self.loadPlugin()"
            },
            "fileName": "lib/scarlet.js"
        },
        {
            "tags": [],
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            },
            "isPrivate": false,
            "code": "function isObjectLiteral(_obj) {\n\tvar _test = _obj;\n\treturn (typeof _obj !== 'object' || _obj === null ?\n\t\tfalse :\n\t\t((function() {\n\t\t\twhile (!false) {\n\t\t\t\tif (Object.getPrototypeOf(_test = Object.getPrototypeOf(_test)) === null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Object.getPrototypeOf(_obj) === _test;\n\t\t})()));\n}\n\nfunction getAllPropertyNames(obj) {\n\tvar props = [];\n\n\tvar getProperties = function(){\n\t\tObject.getOwnPropertyNames(obj).forEach(function(prop) {\n\t\t\tif (props.indexOf(prop) === -1) {\n\t\t\t\tprops.push(prop);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar objectPrototype;\n\tdo {\n\t\tgetProperties();\n\t\tobjectPrototype = Object.getPrototypeOf(obj);\n\t} while (objectPrototype);\n\n\treturn props;\n}\n\nvar names = getAllPropertyNames(new AnyObject());\n\nfor (var index = 0; index < names.length; index++) {\n\tconsole.log(names[index]);\n}",
            "ctx": {
                "type": "function",
                "name": "isObjectLiteral",
                "string": "isObjectLiteral()"
            },
            "fileName": "lib/extensions/console.js"
        },
        {
            "tags": [],
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            },
            "isPrivate": false,
            "code": "function Enumerable() {\n\n\tvar self = this;\n\n\tself.arrayFor = function(array, callback) {\n\t\tfor (var i = 0; i < array.length; i++) {\n\t\t\tcallback(array[i], i, array);\n\t\t}\n\t};\n\n\tself.funcFor = function(object, callback) {\n\t\tfor (var key in object) {\n\t\t\tcallback(object[key], key, object);\n\t\t}\n\t};\n\n\tself.stringFor = function(string, callback) {\n\t\tself.arrayFor(string.split(\"\"), function(chr, index) {\n\t\t\tcallback(chr, index, string);\n\t\t});\n\t};\n\n\tself.allEach = function(object, callback) {\n\t\tObject.getOwnPropertyNames(object).forEach(function(property) {\n\t\t\tcallback(object[property], property, object);\n\t\t});\n\t};\n\n\tself.forEach = function(object, callback) {\n\t\tif (object) {\n\t\t\tvar resolve = self.funcFor;\n\t\t\tif (object instanceof Function) {\n\t\t\t\tresolve = self.funcFor;\n\t\t\t} else if (typeof object == \"string\") {\n\t\t\t\tresolve = self.stringFor;\n\t\t\t} else if (typeof object.length == \"number\") {\n\t\t\t\tresolve = self.arrayFor;\n\t\t\t}\n\t\t\tresolve(object, callback);\n\t\t}\n\t};\n\n}\n\nmodule.exports = new Enumerable();",
            "ctx": {
                "type": "function",
                "name": "Enumerable",
                "string": "Enumerable()"
            },
            "fileName": "lib/extensions/enumerable.js"
        },
        {
            "tags": [],
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            },
            "isPrivate": false,
            "code": "module.exports = function(ctor, superCtor) {\n\tctor.super_ = superCtor;\n\tctor.prototype = Object.create(superCtor.prototype, {\n\t\tconstructor: {\n\t\t\tvalue: ctor,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t}\n\t});\n};",
            "ctx": {
                "type": "method",
                "receiver": "module",
                "name": "exports",
                "string": "module.exports()"
            },
            "fileName": "lib/extensions/inherits.js"
        },
        {
            "tags": [],
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            },
            "isPrivate": false,
            "code": "function Uuid(){\n\n\tfunction s4() {\n\t\treturn Math.floor((1 + Math.random()) * 0x10000)\n\t\t\t\t.toString(16)\n\t\t\t\t.substring(1);\n\t}\n\n\tfunction guid() {\n\t\treturn s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n\t\t\t\ts4() + '-' + s4() + s4() + s4();\n\t}\n\n\tthis.next = function(){\n\t\treturn guid();\n\t};\n}\n\nmodule.exports = new Uuid();",
            "ctx": {
                "type": "function",
                "name": "Uuid",
                "string": "Uuid()"
            },
            "fileName": "lib/extensions/uuid.js"
        }
    ],
    "mox": [
        {
            "params": [],
            "name": "exports",
            "type": "property",
            "fileName": "lib/index.js",
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            }
        },
        {
            "params": [],
            "name": "assert",
            "type": "declaration",
            "fileName": "lib/interceptor.js",
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            }
        },
        {
            "params": [],
            "name": "args",
            "type": {
                "types": [
                    "Object"
                ]
            },
            "fileName": "lib/invocation.js",
            "description": {
                "full": "<p>The original arguments passed into the function being intercepted</p>",
                "summary": "<p>The original arguments passed into the function being intercepted</p>",
                "body": ""
            },
            "category": "Invocation Attributes"
        },
        {
            "params": [],
            "name": "object",
            "type": {
                "types": [
                    "Object"
                ]
            },
            "fileName": "lib/invocation.js",
            "description": {
                "full": "<p>The reference to self for the original/called methd</p>",
                "summary": "<p>The reference to self for the original/called methd</p>",
                "body": ""
            },
            "category": "Invocation Attributes"
        },
        {
            "params": [],
            "name": "method",
            "type": {
                "types": [
                    "Function"
                ]
            },
            "fileName": "lib/invocation.js",
            "description": {
                "full": "<p>The method being intercepted</p>",
                "summary": "<p>The method being intercepted</p>",
                "body": ""
            },
            "category": "Invocation Attributes"
        },
        {
            "params": [],
            "name": "result",
            "type": {
                "types": [
                    "Any"
                ]
            },
            "fileName": "lib/invocation.js",
            "description": {
                "full": "<p>The result of the method being intercepted</p>",
                "summary": "<p>The result of the method being intercepted</p>",
                "body": ""
            },
            "category": "Invocation Attributes"
        },
        {
            "params": [],
            "name": "proceed",
            "type": "method",
            "fileName": "lib/invocation.js",
            "description": {
                "full": "<p>Calls the intercepted method</p>",
                "summary": "<p>Calls the intercepted method</p>",
                "body": ""
            },
            "category": "Invocation Attributes",
            "method": "proceed",
            "return": {
                "types": [
                    "Function",
                    "Object"
                ],
                "description": "of the result of the original method call"
            }
        },
        {
            "params": [],
            "name": "path",
            "type": "declaration",
            "fileName": "lib/plugins.js",
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            }
        },
        {
            "params": [],
            "name": "enumerable",
            "type": "declaration",
            "fileName": "lib/proxy-instance.js",
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            }
        },
        {
            "params": [],
            "name": "assert",
            "type": "declaration",
            "fileName": "lib/proxy-prototype.js",
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            }
        },
        {
            "params": [
                {
                    "types": [
                        "Array"
                    ],
                    "name": "pluginArr",
                    "description": "- optional array of plugins to load"
                }
            ],
            "name": "Scarlet",
            "type": "function",
            "fileName": "lib/scarlet.js",
            "description": {
                "full": "<p>Creates a Scarlet Instance</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet\n    .intercept(someFunction)\n    .using(someInterceptorFunction);\n</pre></div>",
                "summary": "<p>Creates a Scarlet Instance</p>",
                "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet\n    .intercept(someFunction)\n    .using(someInterceptorFunction);\n</pre></div>"
            },
            "category": "Interception Methods",
            "class": "Scarlet",
            "constructor": true
        },
        {
            "params": [
                {
                    "types": [
                        "Function",
                        "Object"
                    ],
                    "name": "typeOrInstance",
                    "description": "the type or instance to be intercepted"
                }
            ],
            "name": "intercept",
            "type": "method",
            "fileName": "lib/scarlet.js",
            "description": {
                "full": "<p>Creates a Scarlet interceptor</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.intercept(someFunction);\n</pre></div>",
                "summary": "<p>Creates a Scarlet interceptor</p>",
                "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.intercept(someFunction);\n</pre></div>"
            },
            "category": "Interception Methods",
            "method": "intercept",
            "return": {
                "types": [
                    "Function"
                ],
                "description": "An interceptor object"
            }
        },
        {
            "params": [
                {
                    "types": [
                        "Function"
                    ],
                    "name": "targetMethod",
                    "description": "the method to call when the type or instance is intercepted"
                },
                {
                    "types": [
                        "Function"
                    ],
                    "name": "targetThisContext",
                    "description": "the reference to self/this to be used when calling the intercepotr"
                }
            ],
            "name": "using",
            "type": "method",
            "fileName": "lib/scarlet.js",
            "description": {
                "full": "<p>Attach an interceptor to the type or instance.  Can be chained with multiple using clauses</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\nfunction interceptor1(proceed) { proceed();}\nfunction interceptor2(proceed) { proceed();}\n\nscarlet.intercept(AnyObject) \n        .using(interceptor1) //->indicates the first interceptor to be called\n        .using(interceptor2); //->indicates the second interceptor to be called\n\n//-> AnyObject will now have the two interceptors attached\n</pre></div>    ",
                "summary": "<p>Attach an interceptor to the type or instance.  Can be chained with multiple using clauses</p>",
                "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\nfunction interceptor1(proceed) { proceed();}\nfunction interceptor2(proceed) { proceed();}\n\nscarlet.intercept(AnyObject) \n        .using(interceptor1) //->indicates the first interceptor to be called\n        .using(interceptor2); //->indicates the second interceptor to be called\n\n//-> AnyObject will now have the two interceptors attached\n</pre></div>    "
            },
            "category": "Interception Methods",
            "method": "using",
            "chainable": true,
            "return": {
                "types": [
                    "Function"
                ],
                "description": "A reference to the current interceptor(self)"
            }
        },
        {
            "params": [],
            "name": "resolve",
            "type": "method",
            "fileName": "lib/scarlet.js",
            "description": {
                "full": "<p>Provides the type or instance with the added intercepters. This is needed when intercepting a function.</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\n\nAnyObject = scarlet.intercept(AnyObject)\n                    .using(interceptor)\n                    .resolve();\n\n//-> AnyObject will contain the **interceptor**\n</pre></div>    ",
                "summary": "<p>Provides the type or instance with the added intercepters. This is needed when intercepting a function.</p>",
                "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\n\nAnyObject = scarlet.intercept(AnyObject)\n                    .using(interceptor)\n                    .resolve();\n\n//-> AnyObject will contain the **interceptor**\n</pre></div>    "
            },
            "category": "Interception Methods",
            "method": "resolve",
            "return": {
                "types": [
                    "Function"
                ],
                "description": "A reference to the function being intercepted"
            }
        },
        {
            "params": [
                {
                    "types": [
                        "Function",
                        "Object"
                    ],
                    "name": "pluginPath",
                    "description": "the plugin to be loaded"
                }
            ],
            "name": "loadPlugin",
            "type": "method",
            "fileName": "lib/scarlet.js",
            "description": {
                "full": "<p>loads a plugin</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.loadPlugin(someScarletPlugin);\n</pre></div>",
                "summary": "<p>loads a plugin</p>",
                "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.loadPlugin(someScarletPlugin);\n</pre></div>"
            },
            "category": "Interception Methods",
            "method": "loadPlugin",
            "return": {
                "types": [
                    "Function"
                ],
                "description": "A reference to scarlet(self)"
            },
            "chainable": true
        },
        {
            "params": [],
            "name": "isObjectLiteral",
            "type": "function",
            "fileName": "lib/extensions/console.js",
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            }
        },
        {
            "params": [],
            "name": "Enumerable",
            "type": "function",
            "fileName": "lib/extensions/enumerable.js",
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            }
        },
        {
            "params": [],
            "name": "exports",
            "type": "method",
            "fileName": "lib/extensions/inherits.js",
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            }
        },
        {
            "params": [],
            "name": "Uuid",
            "type": "function",
            "fileName": "lib/extensions/uuid.js",
            "description": {
                "full": "",
                "summary": "",
                "body": ""
            }
        }
    ],
    "categories": [
        {
            "tag": "Invocation Attributes",
            "moxComments": [
                {
                    "params": [],
                    "name": "args",
                    "type": {
                        "types": [
                            "Object"
                        ]
                    },
                    "fileName": "lib/invocation.js",
                    "description": {
                        "full": "<p>The original arguments passed into the function being intercepted</p>",
                        "summary": "<p>The original arguments passed into the function being intercepted</p>",
                        "body": ""
                    },
                    "category": "Invocation Attributes"
                },
                {
                    "params": [],
                    "name": "object",
                    "type": {
                        "types": [
                            "Object"
                        ]
                    },
                    "fileName": "lib/invocation.js",
                    "description": {
                        "full": "<p>The reference to self for the original/called methd</p>",
                        "summary": "<p>The reference to self for the original/called methd</p>",
                        "body": ""
                    },
                    "category": "Invocation Attributes"
                },
                {
                    "params": [],
                    "name": "method",
                    "type": {
                        "types": [
                            "Function"
                        ]
                    },
                    "fileName": "lib/invocation.js",
                    "description": {
                        "full": "<p>The method being intercepted</p>",
                        "summary": "<p>The method being intercepted</p>",
                        "body": ""
                    },
                    "category": "Invocation Attributes"
                },
                {
                    "params": [],
                    "name": "result",
                    "type": {
                        "types": [
                            "Any"
                        ]
                    },
                    "fileName": "lib/invocation.js",
                    "description": {
                        "full": "<p>The result of the method being intercepted</p>",
                        "summary": "<p>The result of the method being intercepted</p>",
                        "body": ""
                    },
                    "category": "Invocation Attributes"
                },
                {
                    "params": [],
                    "name": "proceed",
                    "type": "method",
                    "fileName": "lib/invocation.js",
                    "description": {
                        "full": "<p>Calls the intercepted method</p>",
                        "summary": "<p>Calls the intercepted method</p>",
                        "body": ""
                    },
                    "category": "Invocation Attributes",
                    "method": "proceed",
                    "return": {
                        "types": [
                            "Function",
                            "Object"
                        ],
                        "description": "of the result of the original method call"
                    }
                }
            ]
        },
        {
            "tag": "Interception Methods",
            "moxComments": [
                {
                    "params": [
                        {
                            "types": [
                                "Array"
                            ],
                            "name": "pluginArr",
                            "description": "- optional array of plugins to load"
                        }
                    ],
                    "name": "Scarlet",
                    "type": "function",
                    "fileName": "lib/scarlet.js",
                    "description": {
                        "full": "<p>Creates a Scarlet Instance</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet\n    .intercept(someFunction)\n    .using(someInterceptorFunction);\n</pre></div>",
                        "summary": "<p>Creates a Scarlet Instance</p>",
                        "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet\n    .intercept(someFunction)\n    .using(someInterceptorFunction);\n</pre></div>"
                    },
                    "category": "Interception Methods",
                    "class": "Scarlet",
                    "constructor": true
                },
                {
                    "params": [
                        {
                            "types": [
                                "Function",
                                "Object"
                            ],
                            "name": "typeOrInstance",
                            "description": "the type or instance to be intercepted"
                        }
                    ],
                    "name": "intercept",
                    "type": "method",
                    "fileName": "lib/scarlet.js",
                    "description": {
                        "full": "<p>Creates a Scarlet interceptor</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.intercept(someFunction);\n</pre></div>",
                        "summary": "<p>Creates a Scarlet interceptor</p>",
                        "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.intercept(someFunction);\n</pre></div>"
                    },
                    "category": "Interception Methods",
                    "method": "intercept",
                    "return": {
                        "types": [
                            "Function"
                        ],
                        "description": "An interceptor object"
                    }
                },
                {
                    "params": [
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "targetMethod",
                            "description": "the method to call when the type or instance is intercepted"
                        },
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "targetThisContext",
                            "description": "the reference to self/this to be used when calling the intercepotr"
                        }
                    ],
                    "name": "using",
                    "type": "method",
                    "fileName": "lib/scarlet.js",
                    "description": {
                        "full": "<p>Attach an interceptor to the type or instance.  Can be chained with multiple using clauses</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\nfunction interceptor1(proceed) { proceed();}\nfunction interceptor2(proceed) { proceed();}\n\nscarlet.intercept(AnyObject) \n        .using(interceptor1) //->indicates the first interceptor to be called\n        .using(interceptor2); //->indicates the second interceptor to be called\n\n//-> AnyObject will now have the two interceptors attached\n</pre></div>    ",
                        "summary": "<p>Attach an interceptor to the type or instance.  Can be chained with multiple using clauses</p>",
                        "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\nfunction interceptor1(proceed) { proceed();}\nfunction interceptor2(proceed) { proceed();}\n\nscarlet.intercept(AnyObject) \n        .using(interceptor1) //->indicates the first interceptor to be called\n        .using(interceptor2); //->indicates the second interceptor to be called\n\n//-> AnyObject will now have the two interceptors attached\n</pre></div>    "
                    },
                    "category": "Interception Methods",
                    "method": "using",
                    "chainable": true,
                    "return": {
                        "types": [
                            "Function"
                        ],
                        "description": "A reference to the current interceptor(self)"
                    }
                },
                {
                    "params": [],
                    "name": "resolve",
                    "type": "method",
                    "fileName": "lib/scarlet.js",
                    "description": {
                        "full": "<p>Provides the type or instance with the added intercepters. This is needed when intercepting a function.</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\n\nAnyObject = scarlet.intercept(AnyObject)\n                    .using(interceptor)\n                    .resolve();\n\n//-> AnyObject will contain the **interceptor**\n</pre></div>    ",
                        "summary": "<p>Provides the type or instance with the added intercepters. This is needed when intercepting a function.</p>",
                        "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\n\nAnyObject = scarlet.intercept(AnyObject)\n                    .using(interceptor)\n                    .resolve();\n\n//-> AnyObject will contain the **interceptor**\n</pre></div>    "
                    },
                    "category": "Interception Methods",
                    "method": "resolve",
                    "return": {
                        "types": [
                            "Function"
                        ],
                        "description": "A reference to the function being intercepted"
                    }
                },
                {
                    "params": [
                        {
                            "types": [
                                "Function",
                                "Object"
                            ],
                            "name": "pluginPath",
                            "description": "the plugin to be loaded"
                        }
                    ],
                    "name": "loadPlugin",
                    "type": "method",
                    "fileName": "lib/scarlet.js",
                    "description": {
                        "full": "<p>loads a plugin</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.loadPlugin(someScarletPlugin);\n</pre></div>",
                        "summary": "<p>loads a plugin</p>",
                        "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.loadPlugin(someScarletPlugin);\n</pre></div>"
                    },
                    "category": "Interception Methods",
                    "method": "loadPlugin",
                    "return": {
                        "types": [
                            "Function"
                        ],
                        "description": "A reference to scarlet(self)"
                    },
                    "chainable": true
                }
            ]
        }
    ],
    "files": [
        {
            "tag": "lib/index.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "exports",
                    "type": "property",
                    "fileName": "lib/index.js",
                    "description": {
                        "full": "",
                        "summary": "",
                        "body": ""
                    }
                }
            ]
        },
        {
            "tag": "lib/interceptor.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "assert",
                    "type": "declaration",
                    "fileName": "lib/interceptor.js",
                    "description": {
                        "full": "",
                        "summary": "",
                        "body": ""
                    }
                }
            ]
        },
        {
            "tag": "lib/invocation.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "args",
                    "type": {
                        "types": [
                            "Object"
                        ]
                    },
                    "fileName": "lib/invocation.js",
                    "description": {
                        "full": "<p>The original arguments passed into the function being intercepted</p>",
                        "summary": "<p>The original arguments passed into the function being intercepted</p>",
                        "body": ""
                    },
                    "category": "Invocation Attributes"
                },
                {
                    "params": [],
                    "name": "object",
                    "type": {
                        "types": [
                            "Object"
                        ]
                    },
                    "fileName": "lib/invocation.js",
                    "description": {
                        "full": "<p>The reference to self for the original/called methd</p>",
                        "summary": "<p>The reference to self for the original/called methd</p>",
                        "body": ""
                    },
                    "category": "Invocation Attributes"
                },
                {
                    "params": [],
                    "name": "method",
                    "type": {
                        "types": [
                            "Function"
                        ]
                    },
                    "fileName": "lib/invocation.js",
                    "description": {
                        "full": "<p>The method being intercepted</p>",
                        "summary": "<p>The method being intercepted</p>",
                        "body": ""
                    },
                    "category": "Invocation Attributes"
                },
                {
                    "params": [],
                    "name": "result",
                    "type": {
                        "types": [
                            "Any"
                        ]
                    },
                    "fileName": "lib/invocation.js",
                    "description": {
                        "full": "<p>The result of the method being intercepted</p>",
                        "summary": "<p>The result of the method being intercepted</p>",
                        "body": ""
                    },
                    "category": "Invocation Attributes"
                },
                {
                    "params": [],
                    "name": "proceed",
                    "type": "method",
                    "fileName": "lib/invocation.js",
                    "description": {
                        "full": "<p>Calls the intercepted method</p>",
                        "summary": "<p>Calls the intercepted method</p>",
                        "body": ""
                    },
                    "category": "Invocation Attributes",
                    "method": "proceed",
                    "return": {
                        "types": [
                            "Function",
                            "Object"
                        ],
                        "description": "of the result of the original method call"
                    }
                }
            ]
        },
        {
            "tag": "lib/plugins.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "path",
                    "type": "declaration",
                    "fileName": "lib/plugins.js",
                    "description": {
                        "full": "",
                        "summary": "",
                        "body": ""
                    }
                }
            ]
        },
        {
            "tag": "lib/proxy-instance.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "enumerable",
                    "type": "declaration",
                    "fileName": "lib/proxy-instance.js",
                    "description": {
                        "full": "",
                        "summary": "",
                        "body": ""
                    }
                }
            ]
        },
        {
            "tag": "lib/proxy-prototype.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "assert",
                    "type": "declaration",
                    "fileName": "lib/proxy-prototype.js",
                    "description": {
                        "full": "",
                        "summary": "",
                        "body": ""
                    }
                }
            ]
        },
        {
            "tag": "lib/scarlet.js",
            "moxComments": [
                {
                    "params": [
                        {
                            "types": [
                                "Array"
                            ],
                            "name": "pluginArr",
                            "description": "- optional array of plugins to load"
                        }
                    ],
                    "name": "Scarlet",
                    "type": "function",
                    "fileName": "lib/scarlet.js",
                    "description": {
                        "full": "<p>Creates a Scarlet Instance</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet\n    .intercept(someFunction)\n    .using(someInterceptorFunction);\n</pre></div>",
                        "summary": "<p>Creates a Scarlet Instance</p>",
                        "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet\n    .intercept(someFunction)\n    .using(someInterceptorFunction);\n</pre></div>"
                    },
                    "category": "Interception Methods",
                    "class": "Scarlet",
                    "constructor": true
                },
                {
                    "params": [
                        {
                            "types": [
                                "Function",
                                "Object"
                            ],
                            "name": "typeOrInstance",
                            "description": "the type or instance to be intercepted"
                        }
                    ],
                    "name": "intercept",
                    "type": "method",
                    "fileName": "lib/scarlet.js",
                    "description": {
                        "full": "<p>Creates a Scarlet interceptor</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.intercept(someFunction);\n</pre></div>",
                        "summary": "<p>Creates a Scarlet interceptor</p>",
                        "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.intercept(someFunction);\n</pre></div>"
                    },
                    "category": "Interception Methods",
                    "method": "intercept",
                    "return": {
                        "types": [
                            "Function"
                        ],
                        "description": "An interceptor object"
                    }
                },
                {
                    "params": [
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "targetMethod",
                            "description": "the method to call when the type or instance is intercepted"
                        },
                        {
                            "types": [
                                "Function"
                            ],
                            "name": "targetThisContext",
                            "description": "the reference to self/this to be used when calling the intercepotr"
                        }
                    ],
                    "name": "using",
                    "type": "method",
                    "fileName": "lib/scarlet.js",
                    "description": {
                        "full": "<p>Attach an interceptor to the type or instance.  Can be chained with multiple using clauses</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\nfunction interceptor1(proceed) { proceed();}\nfunction interceptor2(proceed) { proceed();}\n\nscarlet.intercept(AnyObject) \n        .using(interceptor1) //->indicates the first interceptor to be called\n        .using(interceptor2); //->indicates the second interceptor to be called\n\n//-> AnyObject will now have the two interceptors attached\n</pre></div>    ",
                        "summary": "<p>Attach an interceptor to the type or instance.  Can be chained with multiple using clauses</p>",
                        "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\nfunction interceptor1(proceed) { proceed();}\nfunction interceptor2(proceed) { proceed();}\n\nscarlet.intercept(AnyObject) \n        .using(interceptor1) //->indicates the first interceptor to be called\n        .using(interceptor2); //->indicates the second interceptor to be called\n\n//-> AnyObject will now have the two interceptors attached\n</pre></div>    "
                    },
                    "category": "Interception Methods",
                    "method": "using",
                    "chainable": true,
                    "return": {
                        "types": [
                            "Function"
                        ],
                        "description": "A reference to the current interceptor(self)"
                    }
                },
                {
                    "params": [],
                    "name": "resolve",
                    "type": "method",
                    "fileName": "lib/scarlet.js",
                    "description": {
                        "full": "<p>Provides the type or instance with the added intercepters. This is needed when intercepting a function.</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\n\nAnyObject = scarlet.intercept(AnyObject)\n                    .using(interceptor)\n                    .resolve();\n\n//-> AnyObject will contain the **interceptor**\n</pre></div>    ",
                        "summary": "<p>Provides the type or instance with the added intercepters. This is needed when intercepting a function.</p>",
                        "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">function AnyObject() {};\n\nAnyObject = scarlet.intercept(AnyObject)\n                    .using(interceptor)\n                    .resolve();\n\n//-> AnyObject will contain the **interceptor**\n</pre></div>    "
                    },
                    "category": "Interception Methods",
                    "method": "resolve",
                    "return": {
                        "types": [
                            "Function"
                        ],
                        "description": "A reference to the function being intercepted"
                    }
                },
                {
                    "params": [
                        {
                            "types": [
                                "Function",
                                "Object"
                            ],
                            "name": "pluginPath",
                            "description": "the plugin to be loaded"
                        }
                    ],
                    "name": "loadPlugin",
                    "type": "method",
                    "fileName": "lib/scarlet.js",
                    "description": {
                        "full": "<p>loads a plugin</p>\n\n<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.loadPlugin(someScarletPlugin);\n</pre></div>",
                        "summary": "<p>loads a plugin</p>",
                        "body": "<h4>Example:</h4>\n\n<div class=\"highlight\"><pre lang=\"javascript\">Scarlet.loadPlugin(someScarletPlugin);\n</pre></div>"
                    },
                    "category": "Interception Methods",
                    "method": "loadPlugin",
                    "return": {
                        "types": [
                            "Function"
                        ],
                        "description": "A reference to scarlet(self)"
                    },
                    "chainable": true
                }
            ]
        },
        {
            "tag": "lib/extensions/console.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "isObjectLiteral",
                    "type": "function",
                    "fileName": "lib/extensions/console.js",
                    "description": {
                        "full": "",
                        "summary": "",
                        "body": ""
                    }
                }
            ]
        },
        {
            "tag": "lib/extensions/enumerable.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "Enumerable",
                    "type": "function",
                    "fileName": "lib/extensions/enumerable.js",
                    "description": {
                        "full": "",
                        "summary": "",
                        "body": ""
                    }
                }
            ]
        },
        {
            "tag": "lib/extensions/inherits.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "exports",
                    "type": "method",
                    "fileName": "lib/extensions/inherits.js",
                    "description": {
                        "full": "",
                        "summary": "",
                        "body": ""
                    }
                }
            ]
        },
        {
            "tag": "lib/extensions/uuid.js",
            "moxComments": [
                {
                    "params": [],
                    "name": "Uuid",
                    "type": "function",
                    "fileName": "lib/extensions/uuid.js",
                    "description": {
                        "full": "",
                        "summary": "",
                        "body": ""
                    }
                }
            ]
        }
    ],
    "name": "Scarlet"
}